# coding=utf-8
"""
Top20问题.
    无任何前提。
    1、堆排序，最小堆  nlogn
    2、快排    nlogn
    3、快排版的选择排序，同时利用memory记录每次算到过的结果，看是否能利用。如果top数比总数少很多，还是比快排要优
    纯数字类型
    1、基数排序， 缺点是可能占用大量的空间
    2、最坏时间为线性的选择算法

不同问题的前提条件不一样，注意利用及发掘隐藏的条件。是否是基于数字的，是否互异，不是互异是否需要合并结果
比如：给n个已经排序的数组，求top20.
    隐含条件：
    1、每个数组最长有效长度20.   总个数： 20 * n
    2、已经排序了。 如果再去排序，是否是浪费了这个条件
    3、选择算法，从里面选出20个。
    4、最坏线性的选择算法，每次去排除几乎一半的元素。递归直到变成一维数据，排序。
        在达到一维之前，每次都只需要做选择即可。常数时间计算出需要选择出第几个元素。使用快排版的选择算法去选择
        一维数据，一样可以用选择数据。
        最后是20个未排序。
        算法是线性的。比较次数也相当有效。最优

真是的问题：
    1、访问日志按天就行计算并排序，求一年里面，访问最多的用户orIP，这时需要合并相同的用户及IP
    2、如果求一年中，按每天的结果就行排序，则回到top20问题（最坏线性选择）
"""